File Tree:
├── src/
│   ├── extension.ts
│   ├── generateContext.js
│   ├── generateContext.js.map
│   ├── generateContext.ts
│   ├── models/
│   │   ├── FileNode.js
│   │   ├── FileNode.js.map
│   │   └── FileNode.ts
│   └── treeDataProvider.ts

Files:

--- Start of src/extension.ts ---
// src/extension.ts
import * as vscode from 'vscode';
import { FileTreeProvider } from './treeDataProvider';
import { FileNode } from './models/FileNode';
import { generateContext } from './generateContext';
import * as path from 'path';
import * as fs from 'fs/promises';

export function activate(context: vscode.ExtensionContext) {
    const workspaceRoot = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri.fsPath : '';

    // Load persisted selections from global state
    const persistedSelections: string[] = context.globalState.get('checkedFiles', []);
    const checkedFiles = new Set<string>(persistedSelections);

    console.log(`Persisted checked files: ${persistedSelections.join(', ')}`);

    const treeDataProvider = new FileTreeProvider(workspaceRoot, checkedFiles);
    vscode.window.registerTreeDataProvider('contextGeneratorView', treeDataProvider);

    vscode.commands.registerCommand('contextGenerator.toggleCheckbox', async (element: FileNode) => {
        if (isDirectory(element)) {
            // If it's a directory, toggle all child files
            const isChecked = checkedFiles.has(element.uri.fsPath);
            const allChildFilePaths = await getAllChildFiles(element.uri.fsPath);

            if (isChecked) {
                // Deselect all child files
                allChildFilePaths.forEach(filePath => checkedFiles.delete(filePath));
                console.log(`Unchecked all children of ${element.uri.fsPath}`);
            } else {
                // Select all child files
                allChildFilePaths.forEach(filePath => checkedFiles.add(filePath));
                console.log(`Checked all children of ${element.uri.fsPath}`);
            }
        } else {
            // It's a file, toggle its selection
            if (element.checked) {
                checkedFiles.delete(element.uri.fsPath);
                console.log(`Unchecked: ${element.uri.fsPath}`);
            } else {
                checkedFiles.add(element.uri.fsPath);
                console.log(`Checked: ${element.uri.fsPath}`);
            }
        }

        treeDataProvider.refresh();

        // Persist the selection
        const allCheckedFiles = Array.from(checkedFiles);
        context.globalState.update('checkedFiles', allCheckedFiles);
        console.log(`Current checked files: ${allCheckedFiles.join(', ')}`);
    });

    vscode.commands.registerCommand('contextGenerator.generateContext', () => {
        const selectedFiles = treeDataProvider.getAllCheckedFiles();
        console.log(`Generating context for files: ${selectedFiles.map(file => file.uri.fsPath).join(', ')}`);

        if (selectedFiles.length === 0) {
            vscode.window.showWarningMessage('No files selected. Please select at least one file to generate context.');
            return;
        }

        const config = vscode.workspace.getConfiguration('contextGenerator');
        const outputFile: string = config.get('outputFile') || 'file_context.txt';
        const excludeFiles: string[] = config.get('excludeFiles') || [];
        const excludePaths: string[] = config.get('excludePaths') || [];
        const excludeHidden: boolean = config.get('excludeHidden') ?? true;

        // Filter selectedFiles based on excludeFiles and excludePaths
        const filteredFiles = selectedFiles.filter(file => {
            const fileName = path.basename(file.uri.fsPath);
            const relativePath = path.relative(workspaceRoot, file.uri.fsPath).replace(/\\/g, '/');

            // Exclude based on file names
            if (excludeFiles.includes(fileName)) {
                console.log(`Excluding file by name: ${fileName}`);
                return false;
            }

            // Exclude based on paths
            if (excludePaths.some(excludePath => relativePath.startsWith(excludePath))) {
                console.log(`Excluding file by path: ${relativePath}`);
                return false;
            }

            // Exclude hidden files/directories if configured
            if (excludeHidden && isHidden(relativePath)) {
                console.log(`Excluding hidden file: ${relativePath}`);
                return false;
            }

            return true;
        });

        if (filteredFiles.length === 0) {
            vscode.window.showWarningMessage('No files to include after applying exclusions.');
            return;
        }

        console.log(`Filtered files to include: ${filteredFiles.map(file => file.uri.fsPath).join(', ')}`);

        generateContext(workspaceRoot, outputFile, filteredFiles, excludeFiles, excludePaths, excludeHidden);
    });
}

export function deactivate() {}

/**
 * Determines if a FileNode represents a directory.
 * @param node The FileNode to check.
 * @returns True if it's a directory, else false.
 */
function isDirectory(node: FileNode): boolean {
    return node.collapsibleState !== vscode.TreeItemCollapsibleState.None;
}

/**
 * Recursively collects all file paths under a given directory asynchronously.
 * @param dirPath The directory path to traverse.
 * @returns A promise that resolves to an array of file paths.
 */
async function getAllChildFiles(dirPath: string): Promise<string[]> {
    let results: string[] = [];

    try {
        const list = await fs.readdir(dirPath, { withFileTypes: true });
        for (const dirent of list) {
            const filePath = path.join(dirPath, dirent.name);
            if (dirent.isDirectory()) {
                const subDirFiles = await getAllChildFiles(filePath);
                results = results.concat(subDirFiles);
            } else if (dirent.isFile()) {
                results.push(filePath);
            }
        }
    } catch (err) {
        vscode.window.showErrorMessage(`Error reading directory ${dirPath}: ${err}`);
    }

    return results;
}

/**
 * Determines if a file or directory is hidden based on its relative path.
 * @param relativePath The path relative to the workspace root.
 * @returns True if hidden, else false.
 */
function isHidden(relativePath: string): boolean {
    return relativePath.split(path.sep).some(part => part.startsWith('.'));
}

--- Start of src/generateContext.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateContext = void 0;
// src/generateContext.ts
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const vscode = __importStar(require("vscode"));
function generateContext(workspaceRoot, outputFile, selectedFiles, excludeFiles, excludePaths, excludeHidden) {
    let fileTree = 'File Tree:\n';
    let filesContent = '\nFiles:\n';
    // Build file tree string
    selectedFiles.forEach(file => {
        const relativePath = path.relative(workspaceRoot, file.uri.fsPath).replace(/\\/g, '/');
        fileTree += `├── ${relativePath}\n`;
    });
    // Collect file contents
    selectedFiles.forEach(file => {
        const relativePath = path.relative(workspaceRoot, file.uri.fsPath).replace(/\\/g, '/');
        const baseName = path.basename(file.uri.fsPath);
        if (baseName === '__init__.py') {
            filesContent += `\n--- Start of ${relativePath} ---\n`;
        }
        else {
            try {
                const content = fs.readFileSync(file.uri.fsPath, 'utf-8');
                filesContent += `\n--- Start of ${relativePath} ---\n${content}\n`;
            }
            catch (error) {
                filesContent += `\n--- Start of ${relativePath} ---\nError reading file: ${error}\n`;
            }
        }
    });
    // Write to output file
    const outputPath = path.join(workspaceRoot, outputFile);
    try {
        fs.writeFileSync(outputPath, `${fileTree}\n${filesContent}`);
        vscode.window.showInformationMessage(`Context successfully written to ${outputFile}`);
    }
    catch (error) {
        vscode.window.showErrorMessage(`Failed to write to output file '${outputFile}': ${error}`);
    }
}
exports.generateContext = generateContext;
//# sourceMappingURL=generateContext.js.map

--- Start of src/generateContext.js.map ---
{"version":3,"file":"generateContext.js","sourceRoot":"","sources":["generateContext.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yBAAyB;AACzB,uCAAyB;AACzB,2CAA6B;AAC7B,+CAAiC;AAGjC,SAAgB,eAAe,CAC3B,aAAqB,EACrB,UAAkB,EAClB,aAAyB,EACzB,YAAsB,EACtB,YAAsB,EACtB,aAAsB;IAEtB,IAAI,QAAQ,GAAG,cAAc,CAAC;IAC9B,IAAI,YAAY,GAAG,YAAY,CAAC;IAEhC,yBAAyB;IACzB,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACzB,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QACvF,QAAQ,IAAI,OAAO,YAAY,IAAI,CAAC;IACxC,CAAC,CAAC,CAAC;IAEH,wBAAwB;IACxB,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACzB,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QACvF,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAEhD,IAAI,QAAQ,KAAK,aAAa,EAAE;YAC5B,YAAY,IAAI,kBAAkB,YAAY,QAAQ,CAAC;SAC1D;aAAM;YACH,IAAI;gBACA,MAAM,OAAO,GAAG,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;gBAC1D,YAAY,IAAI,kBAAkB,YAAY,SAAS,OAAO,IAAI,CAAC;aACtE;YAAC,OAAO,KAAK,EAAE;gBACZ,YAAY,IAAI,kBAAkB,YAAY,6BAA6B,KAAK,IAAI,CAAC;aACxF;SACJ;IACL,CAAC,CAAC,CAAC;IAEH,uBAAuB;IACvB,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;IACxD,IAAI;QACA,EAAE,CAAC,aAAa,CAAC,UAAU,EAAE,GAAG,QAAQ,KAAK,YAAY,EAAE,CAAC,CAAC;QAC7D,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,mCAAmC,UAAU,EAAE,CAAC,CAAC;KACzF;IAAC,OAAO,KAAK,EAAE;QACZ,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,mCAAmC,UAAU,MAAM,KAAK,EAAE,CAAC,CAAC;KAC9F;AACL,CAAC;AA1CD,0CA0CC"}

--- Start of src/generateContext.ts ---
// src/generateContext.ts
import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { FileNode } from './models/FileNode';

/**
 * Generates a context file containing the file tree and contents of selected files.
 * @param workspaceRoot The root directory of the workspace.
 * @param outputFile The name of the output file.
 * @param selectedFiles An array of selected FileNodes.
 * @param excludeFiles An array of filenames to exclude.
 * @param excludePaths An array of directory paths to exclude.
 * @param excludeHidden Whether to exclude hidden files and directories.
 */
export function generateContext(
    workspaceRoot: string,
    outputFile: string,
    selectedFiles: FileNode[],
    excludeFiles: string[],
    excludePaths: string[],
    excludeHidden: boolean
) {
    let fileTree = 'File Tree:\n';
    let filesContent = '\nFiles:\n';

    console.log('Starting context generation...');

    // Build file tree string
    selectedFiles.forEach(file => {
        const relativePath = path.relative(workspaceRoot, file.uri.fsPath).replace(/\\/g, '/');
        fileTree += `├── ${relativePath}\n`;
    });

    console.log(`File Tree:\n${fileTree}`);

    // Collect file contents
    selectedFiles.forEach(file => {
        const relativePath = path.relative(workspaceRoot, file.uri.fsPath).replace(/\\/g, '/');
        const baseName = path.basename(file.uri.fsPath);

        // Ensure it's a file before attempting to read
        if (isDirectory(file.uri.fsPath)) {
            console.warn(`Skipping directory: ${relativePath}`);
            return; // Skip directories
        }

        if (baseName === '__init__.py') {
            filesContent += `\n--- Start of ${relativePath} ---\n`;
        } else {
            try {
                const content = fs.readFileSync(file.uri.fsPath, 'utf-8');
                filesContent += `\n--- Start of ${relativePath} ---\n${content}\n`;
            } catch (error) {
                filesContent += `\n--- Start of ${relativePath} ---\nError reading file: ${error}\n`;
                console.error(`Error reading file ${relativePath}: ${error}`);
            }
        }
    });

    console.log(`Files Content:\n${filesContent}`);

    // Write to output file
    const outputPath = path.join(workspaceRoot, outputFile);
    try {
        fs.writeFileSync(outputPath, `${fileTree}\n${filesContent}`);
        vscode.window.showInformationMessage(`Context successfully written to ${outputFile}`);
        console.log(`Context file written to ${outputPath}`);
    } catch (error) {
        vscode.window.showErrorMessage(`Failed to write to output file '${outputFile}': ${error}`);
        console.error(`Failed to write to output file '${outputFile}': ${error}`);
    }
}

/**
 * Determines if a given path is a directory.
 * @param filePath The path to check.
 * @returns True if it's a directory, else false.
 */
function isDirectory(filePath: string): boolean {
    try {
        return fs.statSync(filePath).isDirectory();
    } catch (err) {
        console.error(`Error accessing path ${filePath}: ${err}`);
        return false;
    }
}

--- Start of src/treeDataProvider.ts ---
// src/treeDataProvider.ts
import * as vscode from 'vscode';
import * as path from 'path';
import { FileNode } from './models/FileNode';
import * as fs from 'fs';

/**
 * Provides data for the File Tree View.
 */
export class FileTreeProvider implements vscode.TreeDataProvider<FileNode> {
    private _onDidChangeTreeData: vscode.EventEmitter<FileNode | undefined | void> = new vscode.EventEmitter<FileNode | undefined | void>();
    readonly onDidChangeTreeData: vscode.Event<FileNode | undefined | void> = this._onDidChangeTreeData.event;

    constructor(private workspaceRoot: string, private checkedFiles: Set<string>) {}

    /**
     * Refreshes the Tree View.
     */
    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    /**
     * Returns the TreeItem representation of a FileNode.
     * @param element The FileNode to represent.
     * @returns A TreeItem.
     */
    getTreeItem(element: FileNode): vscode.TreeItem {
        const treeItem = new vscode.TreeItem(element.label, element.collapsibleState);
        treeItem.resourceUri = element.uri;
        treeItem.command = {
            command: 'contextGenerator.toggleCheckbox',
            title: '',
            arguments: [element]
        };

        // Set icons based on checked state
        if (element.checked) {
            treeItem.iconPath = new vscode.ThemeIcon('check');
        } else {
            treeItem.iconPath = new vscode.ThemeIcon('circle-outline');
        }

        // Tooltip
        treeItem.tooltip = element.uri.fsPath;

        return treeItem;
    }

    /**
     * Returns the children of a given FileNode.
     * @param element The parent FileNode.
     * @returns A promise resolving to an array of FileNodes.
     */
    getChildren(element?: FileNode): Thenable<FileNode[]> {
        if (!this.workspaceRoot) {
            vscode.window.showInformationMessage('No workspace folder found');
            return Promise.resolve([]);
        }

        if (element) {
            return Promise.resolve(this.getFileNodes(element.uri.fsPath));
        } else {
            return Promise.resolve(this.getFileNodes(this.workspaceRoot));
        }
    }

    /**
     * Retrieves FileNodes within a given directory path.
     * @param dirPath The directory path.
     * @returns An array of FileNodes.
     */
    private getFileNodes(dirPath: string): FileNode[] {
        let files: string[];
        try {
            files = fs.readdirSync(dirPath);
        } catch (err) {
            vscode.window.showErrorMessage(`Unable to read directory: ${dirPath}`);
            return [];
        }

        // Fetch configuration
        const config = vscode.workspace.getConfiguration('contextGenerator');
        const excludeHidden: boolean = config.get('excludeHidden') ?? true;

        return files.map(file => {
            const fullPath = path.join(dirPath, file);
            let stats: fs.Stats;
            try {
                stats = fs.statSync(fullPath);
            } catch (err) {
                vscode.window.showErrorMessage(`Unable to access file: ${fullPath}`);
                return null;
            }

            const isDirectory = stats.isDirectory();
            const relativePath = path.relative(this.workspaceRoot, fullPath);
            const checked = this.checkedFiles.has(fullPath);

            // Exclude hidden files/directories if configured
            if (excludeHidden && file.startsWith('.')) {
                return null;
            }

            return {
                label: file + (isDirectory ? path.sep : ''),
                collapsibleState: isDirectory ? vscode.TreeItemCollapsibleState.Collapsed : vscode.TreeItemCollapsibleState.None,
                uri: vscode.Uri.file(fullPath),
                checked: checked,
                children: isDirectory ? [] : undefined
            } as FileNode;
        }).filter(node => node !== null) as FileNode[];
    }

    /**
     * Returns an array of FileNodes that are currently checked.
     * @returns An array of checked FileNodes.
     */
    getAllCheckedFiles(): FileNode[] {
        const checkedFileNodes: FileNode[] = [];

        this.checkedFiles.forEach(filePath => {
            checkedFileNodes.push({
                label: path.basename(filePath),
                collapsibleState: vscode.TreeItemCollapsibleState.None,
                uri: vscode.Uri.file(filePath),
                checked: true
            } as FileNode);
        });

        console.log(`getAllCheckedFiles: ${checkedFileNodes.map(file => file.uri.fsPath).join(', ')}`);

        return checkedFileNodes;
    }

    /**
     * Updates the checkedFiles Set.
     * @param paths Array of file paths to set as checked.
     */
    setCheckedFiles(paths: string[]) {
        this.checkedFiles = new Set(paths);
    }
}

--- Start of src/models/FileNode.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=FileNode.js.map

--- Start of src/models/FileNode.js.map ---
{"version":3,"file":"FileNode.js","sourceRoot":"","sources":["FileNode.ts"],"names":[],"mappings":""}

--- Start of src/models/FileNode.ts ---
// src/models/FileNode.ts
import * as vscode from 'vscode';

export interface FileNode {
    label: string;
    collapsibleState: vscode.TreeItemCollapsibleState;
    uri: vscode.Uri;
    checked: boolean;
    children?: FileNode[];
}
